"""
Configuration file generation utilities.

Handles the creation of field and prompt YAML files with proper formatting.
"""

import yaml
from pathlib import Path
from typing import Dict, List, Optional, Tuple


class ConfigGenerator:
    """Generates configuration files for extraction pipelines."""

    @staticmethod
    def create_field_config(
        extractor_name: str,
        fields: Dict[str, List[str]],
        output_dir: Optional[Path] = None
    ) -> Tuple[Path, str]:
        """
        Create field configuration file.

        Args:
            extractor_name: Name of the extractor
            fields: Dictionary of field_name -> allowed_values
            output_dir: Output directory (default: config/fields/)

        Returns:
            Tuple of (file_path, yaml_content)
        """
        if output_dir is None:
            output_dir = Path("config/fields")

        output_dir.mkdir(parents=True, exist_ok=True)

        file_path = output_dir / f"{extractor_name}_fields.yaml"

        # Generate YAML with proper formatting
        yaml_content = yaml.dump(
            fields,
            default_flow_style=False,
            sort_keys=False,
            allow_unicode=True
        )

        # Add header comment
        header = f"# Field definitions for {extractor_name} extraction pipeline\n"
        header += f"# Generated by AI Extraction Pipeline Generator\n\n"

        full_content = header + yaml_content

        return file_path, full_content

    @staticmethod
    def create_prompt_config(
        extractor_name: str,
        system_prompt: str,
        extraction_prompt: str,
        output_dir: Optional[Path] = None
    ) -> Tuple[Path, str]:
        """
        Create prompt configuration file.

        Args:
            extractor_name: Name of the extractor
            system_prompt: System prompt text
            extraction_prompt: Extraction prompt template
            output_dir: Output directory (default: config/prompts/)

        Returns:
            Tuple of (file_path, yaml_content)
        """
        if output_dir is None:
            output_dir = Path("config/prompts")

        output_dir.mkdir(parents=True, exist_ok=True)

        file_path = output_dir / f"{extractor_name}_prompts.yaml"

        # Create prompts dictionary
        prompts = {
            "system": system_prompt,
            "extraction": extraction_prompt
        }

        # Generate YAML with literal style for multi-line strings
        yaml_content = ""
        yaml_content += "system: |\n"
        for line in system_prompt.split('\n'):
            yaml_content += f"  {line}\n"
        yaml_content += "\n"
        yaml_content += "extraction: |\n"
        for line in extraction_prompt.split('\n'):
            yaml_content += f"  {line}\n"

        # Add header comment
        header = f"# Prompt templates for {extractor_name} extraction pipeline\n"
        header += f"# Generated by AI Extraction Pipeline Generator\n\n"

        full_content = header + yaml_content

        return file_path, full_content

    @staticmethod
    def save_file(file_path: Path, content: str) -> bool:
        """
        Save content to file.

        Args:
            file_path: Path to save to
            content: Content to write

        Returns:
            True if successful
        """
        try:
            file_path.parent.mkdir(parents=True, exist_ok=True)
            with open(file_path, 'w') as f:
                f.write(content)
            return True
        except Exception as e:
            print(f"Error saving file: {e}")
            return False

    @staticmethod
    def generate_extractor_template(extractor_name: str) -> str:
        """
        Generate a Python extractor template.

        Args:
            extractor_name: Name of the extractor

        Returns:
            Python code template as string
        """
        class_name = ''.join(word.capitalize() for word in extractor_name.split('_'))

        template = f'''"""
{extractor_name.replace('_', ' ').title()} extraction pipeline.

Auto-generated template by AI Extraction Pipeline Generator.
Customize the methods below based on your specific requirements.
"""

import json
import yaml
from pathlib import Path
from typing import Dict, Any, Optional, List
from datetime import datetime

from ..core.models import TransparencyMetadata
from ..providers import OllamaProvider, OpenAIProvider


class {class_name}Extractor:
    """Extractor for {extractor_name.replace('_', ' ')} data."""

    def __init__(self, config: Dict[str, Any], audit_logger, session_id: str):
        """Initialize extractor."""
        self.config = config
        self.audit_logger = audit_logger
        self.session_id = session_id

        # Output directory
        self.output_dir = Path(config.get('output', {{}}).get('directory', f'output/{{extractor_name}}_extracted'))
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Initialize LLM providers (reuse existing infrastructure)
        # TODO: Add provider initialization

        # Load prompts and field options
        self.prompts = self._load_prompts()
        self.field_options = self._load_field_options()

    def _load_prompts(self) -> Dict[str, str]:
        """Load prompt templates."""
        prompts_file = Path('config/prompts/{extractor_name}_prompts.yaml')
        if prompts_file.exists():
            with open(prompts_file, 'r') as f:
                return yaml.safe_load(f)
        return {{'system': '', 'extraction': ''}}

    def _load_field_options(self) -> Dict[str, List[str]]:
        """Load field options."""
        fields_file = Path('config/fields/{extractor_name}_fields.yaml')
        if fields_file.exists():
            with open(fields_file, 'r') as f:
                return yaml.safe_load(f) or {{}}
        return {{}}

    def _build_prompt(self, record: Any) -> str:
        """Build extraction prompt for a record."""
        # TODO: Implement prompt building logic
        # Format the extraction prompt with record data and field options
        pass

    def _assess_complexity(self, record: Any) -> float:
        """Assess extraction complexity (0.0-1.0)."""
        # TODO: Implement complexity assessment
        # Consider factors like text length, missing data, etc.
        return 0.5

    async def extract_from_record(self, record: Any) -> tuple:
        """Extract data from a single record."""
        # TODO: Implement extraction logic
        # 1. Build prompt
        # 2. Select LLM provider/model
        # 3. Generate extraction
        # 4. Parse response
        # 5. Calculate confidence
        # 6. Create extracted data object
        # 7. Return (extracted_data, error)
        pass

    async def process_batch(self, records: List, batch_size: int = 10):
        """Process multiple records concurrently."""
        # TODO: Implement batch processing
        pass
'''
        return template

    @staticmethod
    def generate_cli_command_snippet(extractor_name: str) -> str:
        """
        Generate CLI command code snippet.

        Args:
            extractor_name: Name of the extractor

        Returns:
            Python code snippet for CLI command
        """
        command_name = f"extract-{extractor_name.replace('_', '-')}"
        class_name = ''.join(word.capitalize() for word in extractor_name.split('_'))

        snippet = f'''
@app.command(name="{command_name}")
def extract_{extractor_name}(
    file: Optional[str] = typer.Option(None, "--file", "-f", help="Input file path"),
    output: Optional[str] = typer.Option(None, "--output", "-o", help="Output file path"),
    provider: Optional[str] = typer.Option(None, "--provider", "-p", help="LLM provider"),
    model: Optional[str] = typer.Option(None, "--model", "-m", help="LLM model"),
    batch_size: Optional[int] = typer.Option(None, "--batch-size", "-b", help="Batch size")
):
    """
    Extract {extractor_name.replace('_', ' ')} data.

    TODO: Add detailed command description
    """
    from .extractors.{extractor_name}_extractor import {class_name}Extractor

    console.print("\\n[bold]{extractor_name.replace('_', ' ').title()} Extraction Pipeline[/bold]\\n")

    # TODO: Add interactive prompts, configuration, and extraction logic
    # See extract_country() in cli.py for a complete example
'''
        return snippet
